<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Colorimeter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

    <style>
        /* ... (All your CSS @keyframes, scrollbar, etc. stays exactly the same) ... */
        @keyframes scan {
            0% { transform: translateY(-100%); }
            100% { transform: translateY(100%); }
        }
        .animate-scan {
            animation: scan 2s linear infinite;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // --- Icon Components (Unchanged) ---
        const Icon = ({ path, className = "w-6 h-6" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d={path} /></svg>
        );
        const Scan = ({ className }) => <Icon className={className} path="M3 7V5a2 2 0 0 1 2-2h2M17 3h2a2 2 0 0 1 2 2v2M21 17v2a2 2 0 0 1-2 2h-2M7 21H5a2 2 0 0 1-2-2v-2M7 12a5 5 0 0 1 5-5 5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5z" />;
        const Activity = ({ className }) => <Icon className={className} path="M22 12h-4l-3 9L9 3l-3 9H2" />;
        const Square = ({ className }) => <Icon className={className} path="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />;
        const Play = ({ className }) => <Icon className={className} path="m5 3 14 9-14 9V3z" />;
        const Plus = ({ className }) => <Icon className={className} path="M5 12h14M12 5v14" />;
        const Copy = ({ className }) => <Icon className={className} path="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2m4 0V2a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2m-6 0h6" />;
        const FileCode = ({ className }) => <Icon className={className} path="m14.5 2.5-3 3H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5l-3-3-3.5 3.5M10 18l-3-3 3-3M14 18l3-3-3-3" />;
        const Download = ({ className }) => <Icon className={className} path="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4M7 10l5 5 5-5M12 15V3" />;
        const Droplets = ({ className }) => <Icon className={className} path="M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.08-1.4-2.65a5.53 5.53 0 0 0-5.2 0C3.57 9.57 3 10.49 3 11.65c0 2.22 1.8 4.05 4 4.05zM12.6 18.28a5.53 5.53 0 0 0 5.2 0c.83-.57 1.4-1.49 1.4-2.65 0-2.22-1.8-4.05-4-4.05-2.2 0-4 1.83-4 4.05 0 1.16.57 2.08 1.4 2.65z" />;
        const X = ({ className }) => <Icon className={className} path="M18 6 6 18M6 6l12 12" />;

        // --- Main React App Component ---
        const App = () => {
            const [currentColor, setCurrentColor] = React.useState({ r: 45, g: 45, b: 45 });
            const [isScanning, setIsScanning] = React.useState(false); // Will mean "is connected"
            const [palette, setPalette] = React.useState([]);
            const [activeHarmony, setActiveHarmony] = React.useState('complementary');
            
            // --- *** NEW: MQTT Connection Logic *** ---
            const MQTT_BROKER_URL = 'wss://broker.hivemq.com:8884/mqtt'; // Secure WebSocket
            const MQTT_TOPIC = 'MPMC/smart-colorimeter/data'; // <-- Must match your ESP32

            React.useEffect(() => {
                // Connect to the MQTT broker when the app loads
                // We access mqtt from the window object, since we loaded it via <script>
                const client = window.mqtt.connect(MQTT_BROKER_URL);

                client.on('connect', () => {
                    console.log('MQTT Connected!');
                    setIsScanning(true); // Use isScanning to show connection status
                    client.subscribe(MQTT_TOPIC, (err) => {
                        if (err) {
                            console.error('Subscription error:', err);
                        }
                    });
                });

                client.on('message', (topic, message) => {
                    // This function is called every time the ESP32 publishes data
                    if (topic === MQTT_TOPIC) {
                        try {
                            const data = JSON.parse(message.toString());
                            setCurrentColor({ r: data.r, g: data.g, b: data.b });
                        } catch (e) {
                            console.error('Failed to parse incoming message:', e);
                        }
                    }
                });

                client.on('close', () => {
                    console.log('MQTT Disconnected');
                    setIsScanning(false);
                });

                client.on('error', (err) => {
                    console.error('MQTT Error:', err);
                    client.end();
                });

                // Clean up the connection when the component unmounts
                return () => {
                    client.end();
                };
            }, []); // The empty array [] means this effect runs only once

            // --- Color Conversion Utilities (Unchanged) ---
            const rgbToHex = (r, g, b) => {
                return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            };
            const rgbToHsl = (r, g, b) => {
                r /= 255; g /= 255; b /= 255;
                const max = Math.max(r, g, b), min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                if (max === min) { h = s = 0; } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                return { h: Math.round(h * 360), s: Math.round(s * 100), l: Math.round(l * 100) };
            };
            const rgbToCmyk = (r, g, b) => {
                let c = 1 - (r / 255), m = 1 - (g / 255), y = 1 - (b / 255);
                let k = Math.min(c, m, y);
                if (k === 1) return { c: 0, m: 0, y: 0, k: 100 };
                c = Math.round(((c - k) / (1 - k)) * 100);
                m = Math.round(((m - k) / (1 - k)) * 100);
                y = Math.round(((y - k) / (1 - k)) * 100);
                k = Math.round(k * 100);
                return { c, m, y, k };
            };
            
            // --- Color Naming (Unchanged) ---
             const getColorName = (r, g, b) => {
                const colorNames = {
                '#FF0000': 'Red', '#00FF00': 'Green', '#0000FF': 'Blue',
                '#FFFF00': 'Yellow', '#FF00FF': 'Magenta', '#00FFFF': 'Cyan',
                '#FFA500': 'Orange', '#800080': 'Purple', '#FFC0CB': 'Pink',
                '#A52A2A': 'Brown', '#808080': 'Gray', '#000000': 'Black',
                '#FFFFFF': 'White', '#FFD700': 'Gold', '#C0C0C0': 'Silver'
                };
                const hex = rgbToHex(r, g, b);
                let closestColor = 'Custom Color';
                let minDistance = Infinity;
                Object.entries(colorNames).forEach(([colorHex, name]) => {
                const cr = parseInt(colorHex.slice(1, 3), 16);
                const cg = parseInt(colorHex.slice(3, 5), 16);
                const cb = parseInt(colorHex.slice(5, 7), 16);
                const distance = Math.sqrt(Math.pow(r - cr, 2) + Math.pow(g - cg, 2) + Math.pow(b - cb, 2));
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = name;
                }
                });
                const l = rgbToHsl(r, g, b).l;
                const s = rgbToHsl(r, g, b).s;
                if (l < 10) return 'Black';
                if (l > 95) return 'White';
                if (s < 10 && l > 10 && l < 90) return 'Gray';
                return closestColor;
            };

            // --- Color Harmony Calculations (Unchanged) ---
            const getComplementary = (r, g, b) => ({ r: 255 - r, g: 255 - g, b: 255 - b });
            const hslToRgb = (h, s, l) => {
                s /= 100; l /= 100;
                const c = (1 - Math.abs(2 * l - 1)) * s, x = c * (1 - Math.abs((h / 60) % 2 - 1)), m = l - c / 2;
                let r, g, b;
                if (h < 60) [r, g, b] = [c, x, 0];
                else if (h < 120) [r, g, b] = [x, c, 0];
                else if (h < 180) [r, g, b] = [0, c, x];
                else if (h < 240) [r, g, b] = [0, x, c];
                else if (h < 300) [r, g, b] = [x, 0, c];
                else [r, g, b] = [c, 0, x];
                return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) };
            };
            const getAnalogous = (r, g, b) => {
                const hsl = rgbToHsl(r, g, b);
                return [hslToRgb((hsl.h + 30) % 360, hsl.s, hsl.l), hslToRgb((hsl.h - 30 + 360) % 360, hsl.s, hsl.l)];
            };
            const getTriadic = (r, g, b) => {
                const hsl = rgbToHsl(r, g, b);
                return [hslToRgb((hsl.h + 120) % 360, hsl.s, hsl.l), hslToRgb((hsl.h + 240) % 360, hsl.s, hsl.l)];
            };
            const getSplitComplementary = (r, g, b) => {
                const hsl = rgbToHsl(r, g, b);
                const compHue = (hsl.h + 180) % 360;
                return [hslToRgb((compHue + 30) % 360, hsl.s, hsl.l), hslToRgb((compHue - 30 + 360) % 360, hsl.s, hsl.l)];
            };

            // --- *** DELETED: fetchColorFromESP32, stopScanning, toggleScanning *** ---

            // --- Palette Management (Unchanged) ---
            const addToPalette = () => {
                if (palette.length < 10) {
                    if (palette.length === 0 || JSON.stringify(palette[palette.length - 1]) !== JSON.stringify(currentColor)) {
                        setPalette([...palette, currentColor]);
                    }
                }
            };
            const removeFromPalette = (index) => {
                setPalette(palette.filter((_, i) => i !== index));
            };
            const copyToClipboard = (text) => {
                navigator.clipboard.writeText(text).then(() => {}, (err) => {
                    console.error('Failed to copy text: ', err);
                });
            };
            const exportPalette = (format) => {
                if (format === 'css') {
                const css = palette.map((color, i) => `--color-${i + 1}: ${rgbToHex(color.r, color.g, color.b)};`).join('\n');
                copyToClipboard(`:root {\n  ${css}\n}`);
                } else if (format === 'hex') {
                const hexCodes = palette.map(c => rgbToHex(c.r, c.g, c.b)).join(', ');
                copyToClipboard(hexCodes);
                } else if (format === 'image') {
                const canvas = document.createElement('canvas');
                canvas.width = palette.length * 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                palette.forEach((color, i) => {
                    ctx.fillStyle = rgbToHex(color.r, color.g, color.b);
                    ctx.fillRect(i * 100, 0, 100, 100);
                });
                canvas.toBlob(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'palette.png';
                    a.click();
                    URL.revokeObjectURL(url);
                });
                }
            };

            // --- Calculate derived data (Unchanged) ---
            const { r, g, b } = currentColor;
            const hex = rgbToHex(r, g, b);
            const hsl = rgbToHsl(r, g, b);
            const cmyk = rgbToCmyk(r, g, b);
            
            // Get color name (Unchanged)
            const [colorName, setColorName] = React.useState('Custom Color');
            React.useEffect(() => {
                setColorName(getColorName(r, g, b));
            }, [currentColor]);

            // Harmonies (Unchanged)
            const complementary = getComplementary(r, g, b);
            const analogous = getAnalogous(r, g, b);
            const triadic = getTriadic(r, g, b);
            const splitComp = getSplitComplementary(r, g, b);
            const harmonies = {
                complementary: [currentColor, complementary],
                analogous: [analogous[0], currentColor, analogous[1]],
                triadic: [currentColor, triadic[0], triadic[1]],
                split: [currentColor, splitComp[0], splitComp[1]]
            };

            // --- Sub-Components (Unchanged) ---
            const ColorSwatch = ({ color, size = 'md', glow = false }) => {
                const sizeClasses = { sm: 'w-10 h-10', md: 'w-16 h-16', lg: 'w-24 h-24' };
                const colorHex = rgbToHex(color.r, color.g, color.b);
                return (
                <div 
                    className={`${sizeClasses[size]} rounded border border-zinc-800 transition-all hover:scale-110 cursor-pointer ${glow ? 'shadow-lg' : ''}`}
                    style={{ 
                    backgroundColor: colorHex,
                    boxShadow: glow ? `0 0 30px ${colorHex}80` : 'none'
                    }}
                    onClick={() => copyToClipboard(colorHex)}
                />
                );
            };

            // --- *** MODIFIED: JSX Output *** ---
            return (
                <div className="min-h-screen bg-black text-zinc-100">
                {/* Background (Unchanged) */}
                <div className="fixed inset-0 bg-[linear-gradient(to_right,#0a0a0a_1px,transparent_1px),linear-gradient(to_bottom,#0a0a0a_1px,transparent_1px)] bg-[size:4rem_4rem] [mask-image:radial-gradient(ellipse_80%_50%_at_50%_0%,#000_70%,transparent_110%)]" />
                
                <div className="relative z-10 max-w-7xl mx-auto px-4 py-8">
                    {/* Header */}
                    <div className="flex flex-col sm:flex-row items-center justify-between mb-12 border-b border-zinc-800 pb-6 gap-4">
                        <div className="flex items-center gap-3">
                            <div className="p-2 bg-zinc-900 rounded-lg border border-zinc-800">
                                <Scan className="w-6 h-6 text-cyan-400" />
                            </div>
                            <div>
                                <h1 className="text-3xl font-bold tracking-tight text-center sm:text-left">SMART COLORIMETER</h1>
                                <p className="text-xs text-zinc-500 font-mono text-center sm:text-left">ESP32_v1.0_MQTT</p>
                            </div>
                        </div>
                        
                        {/* --- MODIFIED: Removed IP Address, showing MQTT Status --- */}
                        <div className="flex items-center gap-2 text-xs font-mono w-full sm:w-auto">
                            <Activity className={`w-3 h-3 ${isScanning ? 'text-green-400 animate-pulse' : 'text-red-500'}`} />
                            <span className="text-zinc-500">BROKER:</span>
                            <span className={isScanning ? 'text-green-400' : 'text-red-500'}>
                                {isScanning ? 'CONNECTED' : 'DISCONNECTED'}
                            </span>
                        </div>
                    </div>

                    {/* Main Grid Layout (Unchanged structure) */}
                    <div className="grid lg:grid-cols-3 gap-6 mb-6">
                    
                        {/* Left Column: Scan & Data */}
                        <div className="lg:col-span-2 space-y-6">
                            {/* Live Preview */}
                            <div className="bg-zinc-950 border border-zinc-800 rounded-lg overflow-hidden">
                                <div className="p-6">
                                <div className="relative">
                                    <div 
                                        className="w-full h-80 rounded border border-zinc-800 transition-all duration-300 relative overflow-hidden"
                                        style={{ backgroundColor: hex }}
                                    >
                                        {/* Scan Lines Effect (now shows if connected) */}
                                        {isScanning && (
                                        <div className="absolute inset-0 opacity-20">
                                            <div className="absolute inset-0 bg-gradient-to-b from-transparent via-white to-transparent animate-scan" />
                                        </div>
                                        )}
                                    </div>
                                    <div className="absolute top-4 left-4 flex gap-2">
                                        <div className="px-3 py-1.5 bg-black/80 backdrop-blur-sm border border-zinc-800 rounded font-mono text-xs">
                                        {colorName.toUpperCase()}
                                        </div>
                                        <div className={`px-3 py-1.5 bg-black/80 backdrop-blur-sm border rounded font-mono text-xs ${
                                        isScanning ? 'border-green-500 text-green-400' : 'border-red-500 text-red-400'
                                        }`}>
                                        {isScanning ? '● LIVE' : '○ OFFLINE'}
                                        </div>
                                    </div>
                                </div>

                                {/* --- MODIFIED: Controls --- */}
                                <div className="grid grid-cols-1 gap-3 mt-6">
                                    {/* --- DELETED: SCAN/STOP Button --- */}
                                    <button
                                        onClick={addToPalette}
                                        disabled={palette.length >= 10 || !isScanning} /* Now disabled if not connected */
                                        className="flex items-center justify-center gap-2 py-4 rounded font-semibold transition-all bg-zinc-900 border border-zinc-800 hover:bg-zinc-800 disabled:opacity-30 disabled:cursor-not-allowed"
                                    >
                                        <Plus className="w-4 h-4" />
                                        ADD TO PALETTE
                                    </button>
                                </div>
                                </div>
                            </div>

                            {/* Color Data Grid (Unchanged) */}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-4">
                                    <div className="text-xs text-zinc-500 mb-2 font-mono">HEX</div>
                                    <div className="flex items-center justify-between">
                                        <span className="font-mono text-xl font-bold">{hex.toUpperCase()}</span>
                                        <Copy className="w-4 h-4 text-zinc-600 hover:text-cyan-400 cursor-pointer transition-colors" onClick={() => copyToClipboard(hex)} />
                                    </div>
                                </div>
                                <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-4">
                                    <div className="text-xs text-zinc-500 mb-2 font-mono">RGB</div>
                                    <div className="flex items-center justify-between">
                                        <span className="font-mono text-sm">{r}, {g}, {b}</span>
                                        <Copy className="w-4 h-4 text-zinc-600 hover:text-cyan-400 cursor-pointer transition-colors" onClick={() => copyToClipboard(`rgb(${r}, ${g}, ${b})`)} />
                                    </div>
                                </div>
                                <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-4">
                                    <div className="text-xs text-zinc-500 mb-2 font-mono">HSL</div>
                                    <div className="flex items-center justify-between">
                                        <span className="font-mono text-sm">{hsl.h}° {hsl.s}% {hsl.l}%</span>
                                        <Copy className="w-4 h-4 text-zinc-600 hover:text-cyan-400 cursor-pointer transition-colors" onClick={() => copyToClipboard(`hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`)} />
                                    </div>
                                </div>
                                <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-4">
                                    <div className="text-xs text-zinc-500 mb-2 font-mono">CMYK</div>
                                    <div className="flex items-center justify-between">
                                        <span className="font-mono text-sm">{cmyk.c} {cmyk.m} {cmyk.y} {cmyk.k}</span>
                                        <Copy className="w-4 h-4 text-zinc-600 hover:text-cyan-400 cursor-pointer transition-colors" onClick={() => copyToClipboard(`cmyk(${cmyk.c}, ${cmyk.m}, ${cmyk.y}, ${cmyk.k})`)} />
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Right Column: Harmony (Unchanged) */}
                        <div className="lg:col-span-1 space-y-6">
                            <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-6">
                                <div className="text-sm font-bold mb-4 text-zinc-400 tracking-wide">COLOR HARMONY</div>
                                <div className="flex flex-wrap gap-2 mb-6">
                                    {Object.keys(harmonies).map(key => (
                                    <button
                                        key={key}
                                        onClick={() => setActiveHarmony(key)}
                                        className={`px-3 py-1.5 rounded text-xs font-mono transition-all border ${
                                        activeHarmony === key
                                            ? 'bg-cyan-500/10 border-cyan-500 text-cyan-400'
                                            : 'bg-zinc-900 border-zinc-800 text-zinc-500 hover:text-zinc-300'
                                        }`}
                                    >
                                        {key.toUpperCase()}
                                    </button>
                                    ))}
                                </div>
                                <div className="flex gap-3 justify-center">
                                    {harmonies[activeHarmony].map((color, i) => (
                                    <ColorSwatch key={i} color={color} size="lg" glow={i === 0 && harmonies[activeHarmony].length > 1} />
                                    ))}
                                </div>
                                <div className="mt-6 p-4 bg-zinc-900 rounded border border-zinc-800">
                                    <div className="text-xs text-zinc-500 mb-2">CLICK TO COPY HEX</div>
                                    <div className="flex flex-wrap gap-2">
                                    {harmonies[activeHarmony].map((color, i) => (
                                        <code key={i} className="text-xs font-mono text-cyan-400 cursor-pointer" onClick={() => copyToClipboard(rgbToHex(color.r, color.g, color.b))}>
                                        {rgbToHex(color.r, color.g, color.b)}
                                        </code>
                                    ))}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Palette Builder (Unchanged) */}
                    <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-6">
                        <div className="flex flex-col md:flex-row items-center justify-between mb-6 gap-4">
                            <div>
                                <h2 className="text-xl font-bold text-center md:text-left">PALETTE</h2>
                                <p className="text-xs text-zinc-500 font-mono text-center md:text-left">{palette.length}/10 colors</p>
                            </div>
                            <div className="flex flex-wrap justify-center gap-2">
                                <button
                                    onClick={() => exportPalette('css')}
                                    disabled={palette.length === 0}
                                    className="flex items-center gap-2 px-4 py-2 bg-zinc-900 border border-zinc-800 hover:border-zinc-700 disabled:opacity-30 disabled:cursor-not-allowed rounded text-sm font-mono transition-all"
                                >
                                    <FileCode className="w-4 h-4" /> CSS
                                </button>
                                <button
                                    onClick={() => exportPalette('hex')}
                                    disabled={palette.length === 0}
                                    className="flex items-center gap-2 px-4 py-2 bg-zinc-900 border border-zinc-800 hover:border-zinc-700 disabled:opacity-30 disabled:cursor-not-allowed rounded text-sm font-mono transition-all"
                                >
                                    <Copy className="w-4 h-4" /> HEX
                                </button>
                                <button
                                    onClick={() => exportPalette('image')}
                                    disabled={palette.length === 0}
                                    className="flex items-center gap-2 px-4 py-2 bg-zinc-900 border border-zinc-800 hover:border-zinc-700 disabled:opacity-30 disabled:cursor-not-allowed rounded text-sm font-mono transition-all"
                                >
                                    <Download className="w-4 h-4" /> PNG
                                </button>
                            </div>
                        </div>
                        {palette.length === 0 ? (
                            <div className="text-center py-20 border-2 border-dashed border-zinc-800 rounded">
                                <Droplets className="w-12 h-12 mx-auto mb-3 text-zinc-700" />
                                <p className="text-zinc-600 text-sm font-mono">NO COLORS SAVED YET</p>
                                <p className="text-zinc-700 text-xs font-mono mt-1">Wait for connection and click 'ADD TO PALETTE'</p>
                            </div>
                        ) : (
                            <div className="grid grid-cols-5 md:grid-cols-10 gap-3">
                                {palette.map((color, index) => (
                                <div key={index} className="relative group">
                                    <div 
                                        className="w-full h-20 rounded border border-zinc-800 transition-all hover:scale-105 cursor-pointer"
                                        style={{ backgroundColor: rgbToHex(color.r, color.g, color.b) }}
                                        onClick={() => copyToClipboard(rgbToHex(color.r, color.g, color.g))}
                                    />
                                    <button
                                        onClick={() => removeFromPalette(index)}
                                        className="absolute -top-2 -right-2 bg-red-500 text-white p-1 rounded-full opacity-0 group-hover:opacity-100 transition-opacity border border-red-600 z-10"
                                    >
                                        <X className="w-3 h-3" />
                                    </button>
                                    <p className="text-xs text-center mt-2 font-mono text-zinc-600 truncate">
                                        {rgbToHex(color.r, color.g, color.b).slice(1)}
                                    </p>
                                </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
                </div>
            );
        };

        // 5. Render the App
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

    </script>
</body>
</html>
